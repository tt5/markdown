# frameworks

Web frameworks are usually run as a WSGI server behind a HTTP ("web") proxy.
The HTTP server included in most frameworks is only there for fast development
and deployment and easy deployment on sites where high efficiency doesn't
matter.

The idea is basically that the HTTP Server
(Apache/Lighttpd/Nginx/Tornado/FAPWS3 etc) is very good at understanding HTTP
and serving static files from the disk. The dynamic content on the other hand
is generated by a Python server using a web framework like
Bottle/Flask/web.py/Pylons/etc. The document produced by the web framework is
then sent back to the HTTP server over WSGI, put in a HTTP Response and sent to
the client. 

NGINX is completely separate program to your Django app. It is running inside
its own process, while Django is running inside a WSGI server process, such as
Gunicorn.  All HTTP requests that hit your Django app have to go through NGINX
first.

You can also configure NGINX to serve static files, like images, directly from
the filesystem, so that requests for these assets don't need to go through
Django

You can adjust the rules in NGINX so that it selectively routes requests to
multiple app servers. You could, for example, run a Wordpress site and a Django
app from the same server

The way nginx and its modules work is determined in the configuration file. By
default, the configuration file is named nginx.conf and placed in the directory
/usr/local/nginx/conf, /etc/nginx, or /usr/local/etc/nginx. 

/etc/nginx/nginx.conf

https://mattsegal.dev/nginx-django-reverse-proxy-config.html
```
events {}
http {
    server {
        listen 8080;
location / {
    proxy_pass http://127.0.0.1:8000;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect http://127.0.0.1:8000 http://foo.com;
}
    }
}
```
WSGI running on localhost:8000
(You can also point proxy_pass at a Unix domain socket, with Gunicorn listening on that socket)
proxy_pass http://unix:/var/run/mysocket.socket;
Gunicorn will read this `Host` header and provide it to you in your Django views via the `request.META` object:

```
# views.py
def my_view(request):
    host = request.META['HTTP_HOST']
    print(host)  # Eg. "foo.com"
    # Prints client IP address: "12.34.56.78"
    print(request.META["HTTP_X_FORWARDED_FOR"])
    # Prints NGINX IP address: "127.0.0.1", ie. localhost
    print(request.META["REMOTE_ADDR"])
    return HttpResponse(f"Got host {host}")
```

```
#settings.py
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
```


sudo systemctl start nginx
sudo systemctl stop nginx
sudo systemctl reload nginx
sudo systemctl restart nginx
sudo systemctl status nginx

curl -v localhost:8080

pip install gunicorn
gunicorn myproject.wsgi
gunicorn --bind unix:/var/run/mysocket.socket myproject.wsgi

https://docs.gunicorn.org/en/stable/deploy.html

# docker

docker pull alpine
suod docker run -it alpine /bin/sh
ps -a

docker commit name/id message
Dockerfile
docker build -t name .
sudo docker run -it name /bin/sh
image prune
rmi
apk add

docker create --name mycontainer someimage
docker start mycontainer

docker run -itd --name mycontainer someimage

pause
unpause

## podman

/etc/containers/storage.conf
systemctl start podman.service
podman pull docker.io/library/alpine
podman images
podman run -dt -p 8080:80/tcp docker.io/library/alpine
podman ps
podman stop -l
podman rm -l
podman rm IMAGE-ID
podman container prune
podman attach --latest
vi -H
c-p c-q
podman commit container-id name
podman images
podman rmi container-id

podman build -t new .
podman run localhost/new
podman run -dt -p 8080:80/tcp localhost/new
podman ps
podman attach CONTAINER-ID/NAMES

# API

You can use the browser for GET, but you'll have to use cURL to POST, PUT, PATCH or DELETE.

-X --request
-d --data
-H --header
-i --include

POST creates a new resource.

curl -X POST -d "userId=5&title=Stuff and Things&body=An amazing blog post about both stuff and things." https://jsonplaceholder.typicode.com/posts

curl -X POST -H "Content-Type: application/json" -d '{"userId": 5, "title": "Stuff and Things", "body": "An amazing blog post about both stuff and things."}' https://jsonplaceholder.typicode.com/posts

PUT updates an existing resource.

curl -X PUT -d "userId=1&title=Something else&body=A new body" https://jsonplaceholder.typicode.com/posts/1

curl -X PUT -H "Content-Type: application/json" -d '{"userId": 1, "title": "Something else", "body": "A new body"}' https://jsonplaceholder.typicode.com/posts/1


PATCH updates an existing resource, and does not require sending the entire body with the request.

curl -X PATCH -d "title='Only change the title'" https://jsonplaceholder.typicode.com/posts/1
curl -X PATCH -H "Content-Type: application/json" -d '{"title": "Only change the title"}' https://jsonplaceholder.typicode.com/posts/1

DELETE removes a resource.

curl -X DELETE https://jsonplaceholder.typicode.com/posts/1

If you need to send additional headers, like Authorization: Bearer or x-jwt-assertion for JWT-based authentication, you can do it through cURL like this.

curl \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <JWT_TOKEN>" \
  -H "x-jwt-assertion: <JWT_TOKEN>" \
  -X POST \
  -d  '{"key1" : "value1", "key2" : "value2"}' \
  https://example.com/

# astro

npm init astro
